<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chat App with Video Calls</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    /* Body Background */
    body {
      background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #333;
      transition: background 0.3s, color 0.3s;
    }
    body.dark-mode {
      background: #121212;
      color: #e0e0e0;
    }
    /* Error Page */
    #errorPage h1 {
      font-weight: 700;
      font-size: 4rem;
    }
    #errorPage p {
      font-size: 1.25rem;
    }
    /* Login Box */
    #loginDiv {
      background: #ffffff;
      border-radius: 1rem;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      padding: 1.5rem;
    }
    body.dark-mode #loginDiv {
      background: #1e1e1e;
    }
    #loginDiv h3 {
      font-weight: 600;
      color: #4a4a4a;
    }
    body.dark-mode #loginDiv h3 {
      color: #e0e0e0;
    }
    #loginDiv input {
      border-radius: 0.5rem;
    }
    /* Chat Container */
    #chatDiv {
      background: #ffffff;
      border-radius: 1rem;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    body.dark-mode #chatDiv {
      background: #1e1e1e;
    }
    /* Chat Box */
    #chatBox {
      display: flex;
      flex-direction: column;
      height: 350px;
      overflow-y: auto;
      background: #f0f4f8;
      border-radius: 0.5rem;
      padding: 1rem;
    }
    body.dark-mode #chatBox {
      background: #222;
    }
    /* Messages */
    .sent,
    .received {
      display: inline-block;
      margin: 4px 0;
      padding: 8px 12px;
      border-radius: 1rem;
      max-width: 75%;
      word-wrap: break-word;
      font-size: 0.95rem;
      transition: background 0.3s, color 0.3s;
    }
    .sent {
      background-color: #d1f7c4;
      align-self: flex-end;
      color: #333;
    }
    .received {
      background-color: #ffffff;
      border: 1px solid #ddd;
      align-self: flex-start;
      color: #333;
    }
    body.dark-mode .sent {
      background-color: #2d4a2e;
      color: #e0e0e0;
    }
    body.dark-mode .received {
      background-color: #333;
      border-color: #444;
      color: #e0e0e0;
    }
    /* Date Divider */
    .date-divider {
      text-align: center;
      margin: 10px 0;
      color: #888;
      font-size: 0.8rem;
      position: relative;
    }
    .date-divider::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background: #ddd;
      z-index: 1;
    }
    .date-divider span {
      background: #f0f4f8;
      padding: 0 10px;
      position: relative;
      z-index: 2;
    }
    body.dark-mode .date-divider span {
      background: #222;
      color: #bbb;
    }
    body.dark-mode .date-divider::before {
      background: #444;
    }
    /* Reactions */
    .message-reactions {
      display: inline-flex;
      gap: 4px;
      margin-top: 4px;
      font-size: 1.2rem;
    }
    /* Emoji Picker */
    .emoji-picker {
      display: none;
      position: absolute;
      background: #ffffff;
      border: 1px solid #ddd;
      padding: 8px 10px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      z-index: 999;
      color: #333;
    }
    body.dark-mode .emoji-picker {
      background: #2c2c2c;
      border-color: #444;
      color: #eee;
    }
    .emoji-picker .emoji {
      font-size: 1.6rem;
      margin: 4px;
      cursor: pointer;
      transition: transform 0.15s ease;
    }
    .emoji-picker .emoji:hover {
      transform: scale(1.3);
    }
    /* Typing Indicator */
    #typingIndicator {
      font-style: italic;
      color: #888;
    }
    body.dark-mode #typingIndicator {
      color: #bbb;
    }
    /* User List */
    #userList > div {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 10px;
      border-bottom: 1px solid #ddd;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    #userList > div:hover {
      background: rgba(0,0,0,0.05);
    }
    body.dark-mode #userList > div {
      border-color: #333;
    }
    body.dark-mode #userList > div:hover {
      background: rgba(255,255,255,0.1);
    }
    /* Inputs */
    .form-control {
      border-radius: 0.5rem;
      transition: background 0.2s, color 0.2s;
    }
    body.dark-mode .form-control {
      background-color: #222;
      border-color: #444;
      color: #eee;
    }
    body.dark-mode .form-control::placeholder {
      color: #888;
    }
    /* Buttons */
    .btn {
      transition: background 0.2s, color 0.2s;
      border-radius: 2rem;
    }
    .btn-link {
      color: #999;
      text-decoration: none;
    }
    .btn-link:hover {
      text-decoration: underline;
    }
    body.dark-mode .btn-primary {
      background-color: #3b71ca;
      border-color: #3b71ca;
    }
    body.dark-mode .btn-secondary {
      background-color: #555;
      border-color: #555;
    }
    body.dark-mode .btn-success {
      background-color: #2e7d32;
      border-color: #2e7d32;
    }
    body.dark-mode .btn-link {
      color: #ccc;
    }
    body.dark-mode .btn-link:hover {
      color: #fff;
    }
    .app-header {
      background-color: #007bff;
      width: 100%;
      border-radius: 0.5rem;
      color: #fff;
      padding: 0.75rem;
    }
    .app-header h4 {
      margin: 0;
      font-size: 1.4rem;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-weight: 500;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    /* Call UI */
    #callContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      flex-direction: column;
    }
    #callContainer.active {
      display: flex;
    }
    #callBox {
      background: white;
      border-radius: 1rem;
      padding: 2rem;
      text-align: center;
      max-width: 400px;
      width: 90%;
      margin-bottom: 2rem;
    }
    body.dark-mode #callBox {
      background: #1e1e1e;
      color: #e0e0e0;
    }
    #callButtons {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    .call-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      border: none;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .call-btn:hover {
      transform: scale(1.1);
    }
    .call-accept {
      background: #28a745;
      color: white;
    }
    .call-decline {
      background: #dc3545;
      color: white;
    }
    .call-end {
      background: #dc3545;
      color: white;
    }
    .user-call-btn {
      margin-left: 10px;
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 1.2rem;
      padding: 5px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .user-call-btn:hover {
      background: rgba(0, 123, 255, 0.1);
    }
    
    /* Video elements */
    #localVideo, #remoteVideo {
      width: 200px;
      height: 150px;
      border-radius: 10px;
      margin: 10px;
      background: #000;
    }
    #localVideo {
      position: absolute;
      bottom: 20px;
      right: 20px;
      border: 2px solid #007bff;
    }
    #remoteVideo {
      max-width: 80%;
      max-height: 60%;
    }
    #videoContainer {
      display: none;
      flex-direction: column;
      align-items: center;
    }
    #videoContainer.active {
      display: flex;
    }
    #debugInfo {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
      max-width: 300px;
      display: none;
    }
  </style>
</head>
<body class="d-flex align-items-center justify-content-center vh-100">
  <div id="hiddenTap" style="
    position:fixed;
    top:0;
    left:0;
    width:50px;
    height:50px;
    opacity:0;
    z-index:9999;
  "></div>
  
  <div id="errorPage" class="text-center" style="display:block;">
    <h1 class="display-4 text-danger">Oops!</h1>
    <p class="lead">Something went wrong.</p>
    <div id="hiddenTap" style="width:100px;height:100px;margin:0 auto;opacity:0;cursor:pointer;">&nbsp;</div>
  </div>

  <div id="chatApp" class="container" style="display:none;max-width:600px;">
    <div id="loginDiv">
      <h3 class="mb-3 text-center">Register Or Login</h3>
      <input id="email" type="email" placeholder="Email" class="form-control mb-2" />
      <input id="password" type="password" placeholder="Password" class="form-control mb-3" />
      <div class="d-grid gap-2">
        <button onclick="login()" class="btn btn-primary">Login</button>
        <button onclick="register()" class="btn btn-secondary">Register</button>
      </div>
    </div>

    <div id="chatDiv" style="display:none;">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <div id="userStatus"></div>
        <button id="toggleTheme" class="btn btn-sm btn-link">üåô Dark Mode</button>
      </div>
      <div id="userList" class="mb-2"></div>
      <div id="typingIndicator" class="small" style="display:none;">User is typing...</div>
      <div id="chatBox"></div>
      <div class="input-group mt-2">
        <input id="messageInput" class="form-control" placeholder="Type a message..." />
        <button onclick="sendMessage()" class="btn btn-success">Send</button>
      </div>
      <div class="form-check mt-2">
        <input class="form-check-input" type="checkbox" id="notificationsToggle">
        <label class="form-check-label" for="notificationsToggle">Enable Notifications</label>
      </div>
      <button onclick="logout()" class="btn btn-link mt-2">Logout</button>
    </div>
  </div>

  <!-- Call UI -->
  <div id="callContainer">
    <div id="videoContainer">
      <video id="remoteVideo" autoplay playsinline></video>
      <video id="localVideo" autoplay playsinline muted></video>
    </div>
    <div id="callBox">
      <h4 id="callStatus">Incoming Call</h4>
      <p id="callerInfo"></p>
      <div id="callButtons">
        <button id="acceptCall" class="call-btn call-accept">üìû</button>
        <button id="declineCall" class="call-btn call-decline">‚úñ</button>
        <button id="endCall" class="call-btn call-end" style="display:none;">‚úñ</button>
      </div>
    </div>
  </div>

  <div id="emojiPicker" class="emoji-picker">
    <span class="emoji" onclick="selectReaction('üëç')">üëç</span>
    <span class="emoji" onclick="selectReaction('‚ù§Ô∏è')">‚ù§Ô∏è</span>
    <span class="emoji" onclick="selectReaction('üòÇ')">üòÇ</span>
    <span class="emoji" onclick="selectReaction('üî•')">üî•</span>
    <span class="emoji" onclick="selectReaction('üòÆ')">üòÆ</span>
    <span class="emoji" onclick="selectReaction('üò¢')">üò¢</span>
    <span class="emoji" onclick="selectReaction('üéâ')">üéâ</span>
  </div>

  <div id="debugInfo"></div>

  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBBsyLZRlDpovituxrkDzBis5a_vWgibGc",
      authDomain: "escape-4f866.firebaseapp.com",
      databaseURL: "https://escape-4f866-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "escape-4f866",
      storageBucket: "escape-4f866.appspot.com", 
      messagingSenderId: "101377850288",
      appId: "1:101377850288:web:e6ceb7a04e702aec467475",
      measurementId: "G-WK0D3KK1S8"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();
  </script>
  <script>
    // Global variables
    let currentUserId = null;
    let chatId = null;
    let selectedUserId = null;
    let callInProgress = false;
    let currentCallId = null;
    let localStream = null;
    let remoteStream = null;
    let peerConnection = null;
    let isCaller = false;

    // DOM elements
    const messageInput = document.getElementById("messageInput");
    const emojiPicker = document.getElementById("emojiPicker");
    const callContainer = document.getElementById("callContainer");
    const videoContainer = document.getElementById("videoContainer");
    const callStatus = document.getElementById("callStatus");
    const callerInfo = document.getElementById("callerInfo");
    const acceptCallBtn = document.getElementById("acceptCall");
    const declineCallBtn = document.getElementById("declineCall");
    const endCallBtn = document.getElementById("endCall");
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const debugInfo = document.getElementById("debugInfo");

    // Enhanced WebRTC configuration with multiple STUN servers
    const configuration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' }
      ],
      iceCandidatePoolSize: 10
    };

    // Debug logging
    function debugLog(message) {
      console.log(message);
      debugInfo.innerHTML += message + '<br>';
      debugInfo.scrollTop = debugInfo.scrollHeight;
      debugInfo.style.display = 'block';
    }

    // Date formatting functions
    function formatDate(timestamp) {
      const date = new Date(timestamp);
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      
      if (date.toDateString() === today.toDateString()) {
        return "Today";
      } else if (date.toDateString() === yesterday.toDateString()) {
        return "Yesterday";
      } else {
        return date.toLocaleDateString();
      }
    }

    function formatDateTime(timestamp) {
      const date = new Date(timestamp);
      return `${formatDate(timestamp)} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
    }

    // Ctrl + Enter for PC
    document.addEventListener("keydown", (e) => {
      if (e.ctrlKey && e.key === "Enter") {
        document.getElementById("errorPage").style.display = "none";
        document.getElementById("chatApp").style.display = "block";
      }
    });

    // Hidden tap area for mobile
    document.getElementById("hiddenTap").addEventListener("click", () => {
      document.getElementById("errorPage").style.display = "none";
      document.getElementById("chatApp").style.display = "block";
    });

    // Login
    function login() {
      const email = document.getElementById("email").value;
      const password = document.getElementById("password").value;
      auth.signInWithEmailAndPassword(email, password).catch((error) => alert(error.message));
    }

    // Register
    function register() {
      const email = document.getElementById("email").value;
      const password = document.getElementById("password").value;
      auth.createUserWithEmailAndPassword(email, password)
        .then((user) => {
          db.ref("users/" + user.user.uid).set({ email: email, online: true });
        })
        .catch((error) => {
          if (error.code === "auth/email-already-in-use") {
            alert("This email is already registered. Please login.");
          } else {
            alert(error.message);
          }
        });
    }

    // Logout
    function logout() {
      if (callInProgress) {
        endCall();
      }
      auth.signOut().then(() => location.reload());
    }

    // Load users list
    function loadUsers() {
      const userList = document.getElementById("userList");
      userList.innerHTML = "<div class='text-muted'>Loading users...</div>";

      db.ref("users").on("value", (snapshot) => {
        userList.innerHTML = "";
        const users = snapshot.val() || {};

        Object.entries(users).forEach(([uid, userData]) => {
          if (uid === currentUserId) return;

          const div = document.createElement("div");
          div.className = "d-flex justify-content-between align-items-center p-1 border-bottom";
          div.style.cursor = "pointer";
          div.onclick = () => startChatWith(uid);

          const leftDiv = document.createElement("div");
          leftDiv.className = "d-flex align-items-center";
          
          const emailSpan = document.createElement("span");
          emailSpan.textContent = userData.email;

          const statusSpan = document.createElement("small");
          statusSpan.className = "text-muted ms-2";
          if (userData.online) {
            statusSpan.textContent = "üü¢ Online";
          } else if (userData.lastOnline) {
            statusSpan.textContent = `Last seen ${formatDateTime(userData.lastOnline)}`;
          } else {
            statusSpan.textContent = "Offline";
          }

          // Add call button
          const callBtn = document.createElement("button");
          callBtn.className = "user-call-btn";
          callBtn.innerHTML = "üìû";
          callBtn.title = "Start video call";
          callBtn.onclick = (e) => {
            e.stopPropagation();
            initiateCall(uid);
          };

          leftDiv.appendChild(emailSpan);
          leftDiv.appendChild(statusSpan);
          
          div.appendChild(leftDiv);
          div.appendChild(callBtn);
          userList.appendChild(div);
        });

        if (userList.innerHTML === "") {
          userList.innerHTML = "<div class='text-muted'>No other users found.</div>";
        }
      });
    }

    // Start chat
    function startChatWith(otherUserId) {
      selectedUserId = otherUserId;
      chatId = currentUserId < otherUserId
        ? `${currentUserId}_${otherUserId}`
        : `${otherUserId}_${currentUserId}`;

      document.getElementById("chatBox").innerHTML = "";
      document.getElementById("userStatus").textContent = "";

      // Status updates
      db.ref(`users/${otherUserId}`).on("value", (snapshot) => {
        const data = snapshot.val();
        if (data.online) {
          document.getElementById("userStatus").textContent = "üü¢ Online";
        } else if (data.lastOnline) {
          document.getElementById("userStatus").textContent = `Last seen ${formatDateTime(data.lastOnline)}`;
        } else {
          document.getElementById("userStatus").textContent = "Offline";
        }
      });

      // Typing indicator
      db.ref(`chats/${chatId}/typing`).on("value", (snapshot) => {
        const typingData = snapshot.val() || {};
        const otherTyping = Object.entries(typingData).some(([uid, isTyping]) => uid !== currentUserId && isTyping);
        document.getElementById("typingIndicator").style.display = otherTyping ? "block" : "none";
      });

      // Messages
      db.ref(`chats/${chatId}/messages`).off();
      db.ref(`chats/${chatId}/messages`).on("child_added", (snapshot) => {
        const msg = snapshot.val();
        const msgId = snapshot.key;
        
        // Add date divider if needed
        const msgDate = formatDate(msg.timestamp);
        const chatBox = document.getElementById("chatBox");
        const lastDateDivider = chatBox.querySelector('.date-divider:last-child');
        const lastDate = lastDateDivider ? lastDateDivider.textContent : null;
        
        if (msgDate !== lastDate) {
          const dateDivider = document.createElement("div");
          dateDivider.className = "date-divider";
          dateDivider.innerHTML = `<span>${msgDate}</span>`;
          chatBox.appendChild(dateDivider);
        }

        const div = document.createElement("div");
        div.className = msg.senderId === currentUserId ? "sent align-self-end" : "received align-self-start";
        div.ondblclick = (e) => showReactionPicker(e, msgId);

        // If replying to a message
        if (msg.replyTo) {
          db.ref(`chats/${chatId}/messages/${msg.replyTo}`).once("value", (snap) => {
            const replied = snap.val();
            if (replied) {
              const replyDiv = document.createElement("div");
              replyDiv.className = "small text-muted mb-1";
              replyDiv.textContent = `Reply to: "${replied.text}"`;
              div.appendChild(replyDiv);
            }
          });
        }

        const textDiv = document.createElement("div");
        textDiv.innerHTML = `${msg.text}<br/><small class="text-muted">${new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</small>`;
        div.appendChild(textDiv);

        // Reply button
        const replyBtn = document.createElement("button");
        replyBtn.className = "btn btn-sm btn-link";
        replyBtn.textContent = "Reply";
        replyBtn.onclick = () => {
          messageInput.dataset.replyTo = msgId;
          messageInput.placeholder = "Replying...";
        };
        div.appendChild(replyBtn);

        // Reactions container
        const reactionDiv = document.createElement("div");
        reactionDiv.id = `reaction-${msgId}`;
        reactionDiv.className = "message-reactions";
        div.appendChild(reactionDiv);

        db.ref(`chats/${chatId}/messages/${msgId}/reactions`).on("value", (snap) => {
          const reactions = snap.val() || {};
          reactionDiv.innerHTML = "";
          const uniqueEmojis = Array.from(new Set(Object.values(reactions)));
          uniqueEmojis.forEach((emoji) => {
            const span = document.createElement("span");
            span.textContent = emoji;
            reactionDiv.appendChild(span);
          });
        });

        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;

        db.ref(`chats/${chatId}/messages/${msgId}/readBy/${currentUserId}`).set(true);

        if (document.getElementById("notificationsToggle").checked && msg.senderId !== currentUserId) {
          if (Notification.permission === "granted") {
            new Notification("New message", { body: msg.text });
          } else if (Notification.permission !== "denied") {
            Notification.requestPermission().then(permission => {
              if (permission === "granted") {
                new Notification("New message", { body: msg.text });
              }
            });
          }
        }
      });
    }

    // Send message
    function sendMessage() {
      if (!selectedUserId) {
        alert("Please select a user to chat with.");
        return;
      }
      const text = messageInput.value.trim();
      if (!text) return;

      const replyTo = messageInput.dataset.replyTo || null;
      const newMsgRef = db.ref(`chats/${chatId}/messages`).push();
      newMsgRef.set({
        text: text,
        senderId: currentUserId,
        timestamp: Date.now(),
        replyTo: replyTo,
        readBy: { [currentUserId]: true }
      });

      messageInput.value = "";
      messageInput.placeholder = "Type a message...";
      delete messageInput.dataset.replyTo;
    }

    // Typing indicator
    messageInput.addEventListener("input", () => {
      if (chatId) {
        db.ref(`chats/${chatId}/typing/${currentUserId}`).set(messageInput.value.trim().length > 0);
      }
    });
    messageInput.addEventListener("blur", () => {
      if (chatId) {
        db.ref(`chats/${chatId}/typing/${currentUserId}`).set(false);
      }
    });

    // Theme toggle
    document.getElementById("toggleTheme").addEventListener("click", () => {
      document.body.classList.toggle("dark-mode");
      document.getElementById("toggleTheme").textContent =
        document.body.classList.contains("dark-mode") ? "‚òÄÔ∏è Light Mode" : "üåô Dark Mode";
    });

    // Reaction picker
    function showReactionPicker(e, msgId) {
      emojiPicker.style.display = "block";
      emojiPicker.style.top = `${e.clientY}px`;
      emojiPicker.style.left = `${e.clientX}px`;
      emojiPicker.dataset.msgId = msgId;
    }

    function selectReaction(emoji) {
      const msgId = emojiPicker.dataset.msgId;
      db.ref(`chats/${chatId}/messages/${msgId}/reactions/${currentUserId}`).set(emoji);
      emojiPicker.style.display = "none";
    }

    // Close picker if clicked outside
    document.addEventListener("click", (e) => {
      if (!e.target.classList.contains("emoji")) {
        emojiPicker.style.display = "none";
      }
    });

    // WebRTC Functions - FIXED ICE CANDIDATE HANDLING
    async function createPeerConnection() {
      try {
        debugLog('Creating peer connection...');
        peerConnection = new RTCPeerConnection(configuration);
        
        // Add local stream to connection
        if (localStream) {
          localStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
            debugLog(`Added track: ${track.kind}`);
          });
        }
        
        // Get remote stream
        peerConnection.ontrack = (event) => {
          debugLog('Received remote track');
          remoteVideo.srcObject = event.streams[0];
          remoteStream = event.streams[0];
          debugLog('Remote video stream set');
        };
        
        // Handle ICE candidates - FIXED: Proper candidate validation and storage
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            debugLog('New ICE candidate: ' + event.candidate.candidate);
            // Store the complete candidate object
            const candidateData = {
              candidate: event.candidate.candidate,
              sdpMid: event.candidate.sdpMid,
              sdpMLineIndex: event.candidate.sdpMLineIndex,
              usernameFragment: event.candidate.usernameFragment
            };
            db.ref(`calls/${currentCallId}/candidates/${currentUserId}`).push(candidateData);
          } else {
            debugLog('All ICE candidates have been generated');
          }
        };
        
        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
          debugLog('Connection state: ' + peerConnection.connectionState);
          callStatus.textContent = "Call " + peerConnection.connectionState;
          
          if (peerConnection.connectionState === 'connected') {
            callStatus.textContent = "Call Connected";
            videoContainer.classList.add('active');
            debugLog('Call connected successfully!');
          } else if (peerConnection.connectionState === 'disconnected' || 
                     peerConnection.connectionState === 'failed') {
            debugLog('Call disconnected or failed');
            endCall();
          }
        };
        
        // Handle ICE connection state
        peerConnection.oniceconnectionstatechange = () => {
          debugLog('ICE connection state: ' + peerConnection.iceConnectionState);
        };
        
        return peerConnection;
      } catch (error) {
        console.error('Error creating peer connection:', error);
        debugLog('Error creating peer connection: ' + error.message);
        alert('Error starting call: ' + error.message);
      }
    }

    async function startCall() {
      try {
        debugLog('Starting call as caller...');
        
        // Get user media
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });
        localVideo.srcObject = localStream;
        debugLog('Local media stream obtained');
        
        // Create peer connection
        await createPeerConnection();
        
        // Create offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        debugLog('Created and set local offer');
        
        // Send offer to Firebase
        db.ref(`calls/${currentCallId}`).update({
          offer: offer,
          from: currentUserId,
          timestamp: Date.now()
        });
        debugLog('Offer sent to Firebase');
        
        // Listen for answers
        db.ref(`calls/${currentCallId}/answer`).on('value', async (snapshot) => {
          const answer = snapshot.val();
          if (answer && answer.from !== currentUserId) {
            debugLog('Received answer from peer');
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            debugLog('Set remote description from answer');
          }
        });
        
        // Listen for ICE candidates - FIXED: Proper candidate retrieval
        db.ref(`calls/${currentCallId}/candidates`).on('child_added', async (snapshot) => {
          const candidateData = snapshot.val();
          if (candidateData.from !== currentUserId && peerConnection.remoteDescription) {
            try {
              debugLog('Processing ICE candidate from peer: ' + candidateData.candidate);
              
              // Validate candidate data exists
              if (!candidateData.candidate) {
                debugLog('No candidate data found');
                return;
              }
              
              const candidate = new RTCIceCandidate({
                candidate: candidateData.candidate,
                sdpMid: candidateData.sdpMid || null,
                sdpMLineIndex: candidateData.sdpMLineIndex || null,
                usernameFragment: candidateData.usernameFragment || null
              });
              
              await peerConnection.addIceCandidate(candidate);
              debugLog('Added ICE candidate from peer');
            } catch (error) {
              console.warn('Error adding ICE candidate:', error);
              debugLog('Error adding ICE candidate: ' + error.message);
            }
          }
        });
        
      } catch (error) {
        console.error('Error starting call:', error);
        debugLog('Error starting call: ' + error.message);
        alert('Error starting call: ' + error.message);
        endCall();
      }
    }

    async function answerCall() {
      try {
        debugLog('Answering call as receiver...');
        
        // Get user media
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });
        localVideo.srcObject = localStream;
        debugLog('Local media stream obtained');
        
        // Create peer connection
        await createPeerConnection();
        
        // Listen for offer with timeout
        const offerPromise = new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            reject(new Error('Offer timeout'));
          }, 10000);
          
          db.ref(`calls/${currentCallId}/offer`).on('value', async (snapshot) => {
            const offer = snapshot.val();
            if (offer && offer.from !== currentUserId) {
              clearTimeout(timeout);
              resolve(offer);
            }
          });
        });
        
        const offer = await offerPromise;
        debugLog('Received offer from caller');
        
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        debugLog('Set remote description from offer');
        
        // Create answer
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        debugLog('Created and set local answer');
        
        // Send answer to Firebase
        db.ref(`calls/${currentCallId}/answer`).set({
          ...answer,
          from: currentUserId
        });
        debugLog('Answer sent to Firebase');
        
        // Listen for ICE candidates - FIXED: Proper candidate retrieval
        db.ref(`calls/${currentCallId}/candidates`).on('child_added', async (snapshot) => {
          const candidateData = snapshot.val();
          if (candidateData.from !== currentUserId && peerConnection.remoteDescription) {
            try {
              debugLog('Processing ICE candidate from peer: ' + candidateData.candidate);
              
              // Validate candidate data exists
              if (!candidateData.candidate) {
                debugLog('No candidate data found');
                return;
              }
              
              const candidate = new RTCIceCandidate({
                candidate: candidateData.candidate,
                sdpMid: candidateData.sdpMid || null,
                sdpMLineIndex: candidateData.sdpMLineIndex || null,
                usernameFragment: candidateData.usernameFragment || null
              });
              
              await peerConnection.addIceCandidate(candidate);
              debugLog('Added ICE candidate from peer');
            } catch (error) {
              console.warn('Error adding ICE candidate:', error);
              debugLog('Error adding ICE candidate: ' + error.message);
            }
          }
        });
        
      } catch (error) {
        console.error('Error answering call:', error);
        debugLog('Error answering call: ' + error.message);
        alert('Error answering call: ' + error.message);
        endCall();
      }
    }

    // Call Management Functions
    function initiateCall(otherUserId) {
      if (callInProgress) {
        alert("You already have an active call. Please end it first.");
        return;
      }
      
      isCaller = true;
      currentCallId = `${currentUserId}_${otherUserId}_${Date.now()}`;
      callInProgress = true;
      
      debugLog('Initiating call with ID: ' + currentCallId);
      
      // Show calling UI
      callStatus.textContent = "Calling...";
      callerInfo.textContent = "Waiting for answer";
      callContainer.classList.add("active");
      acceptCallBtn.style.display = "none";
      declineCallBtn.style.display = "none";
      endCallBtn.style.display = "block";
      
      // Create call in Firebase
      db.ref(`calls/${currentCallId}`).set({
        callerId: currentUserId,
        receiverId: otherUserId,
        status: "calling",
        timestamp: Date.now(),
        type: "video"
      });
      
      // Start the call process
      startCall();
      
      // Listen for call response
      db.ref(`calls/${currentCallId}/status`).on('value', (snapshot) => {
        const status = snapshot.val();
        debugLog('Call status update: ' + status);
        
        if (status === "accepted") {
          callStatus.textContent = "Call Connected";
        } else if (status === "declined" || status === "ended") {
          callStatus.textContent = status === "declined" ? "Call Declined" : "Call Ended";
          setTimeout(endCall, 2000);
        }
      });
    }

    function handleIncomingCall(callId, callData) {
      if (callInProgress) {
        // Auto decline if already in call
        db.ref(`calls/${callId}/status`).set("declined");
        return;
      }
      
      currentCallId = callId;
      callInProgress = true;
      isCaller = false;
      
      debugLog('Handling incoming call: ' + callId);
      
      // Show incoming call UI
      callStatus.textContent = "Incoming Call";
      callerInfo.textContent = `From: ${callData.callerId}`;
      callContainer.classList.add("active");
      acceptCallBtn.style.display = "block";
      declineCallBtn.style.display = "block";
      endCallBtn.style.display = "none";
      
      // Get caller info
      db.ref(`users/${callData.callerId}`).once('value', (snapshot) => {
        const userData = snapshot.val();
        if (userData) {
          callerInfo.textContent = `From: ${userData.email}`;
        }
      });
      
      // Set up button handlers
      acceptCallBtn.onclick = acceptIncomingCall;
      declineCallBtn.onclick = declineIncomingCall;
    }

    function acceptIncomingCall() {
      debugLog('Accepting incoming call');
      db.ref(`calls/${currentCallId}/status`).set("accepted");
      callStatus.textContent = "Connecting...";
      acceptCallBtn.style.display = "none";
      declineCallBtn.style.display = "none";
      endCallBtn.style.display = "block";
      answerCall();
    }

    function declineIncomingCall() {
      debugLog('Declining incoming call');
      db.ref(`calls/${currentCallId}/status`).set("declined");
      callStatus.textContent = "Call Declined";
      setTimeout(endCall, 2000);
    }

    function endCall() {
      debugLog('Ending call');
      
      if (currentCallId) {
        db.ref(`calls/${currentCallId}/status`).set("ended");
        
        // Clean up Firebase listeners
        db.ref(`calls/${currentCallId}`).off();
        db.ref(`calls/${currentCallId}/offer`).off();
        db.ref(`calls/${currentCallId}/answer`).off();
        db.ref(`calls/${currentCallId}/candidates`).off();
        db.ref(`calls/${currentCallId}/status`).off();
        
        // Remove the call data after a delay
        setTimeout(() => {
          db.ref(`calls/${currentCallId}`).remove();
        }, 5000);
        
        currentCallId = null;
      }
      
      // Close peer connection
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      
      // Stop media streams
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      if (remoteStream) {
        remoteStream.getTracks().forEach(track => track.stop());
        remoteStream = null;
      }
      
      // Reset UI
      callInProgress = false;
      callContainer.classList.remove("active");
      videoContainer.classList.remove("active");
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
      debugLog('Call ended and cleaned up');
    }

    // Set up end call button
    endCallBtn.onclick = endCall;

    // Listen for incoming calls
    function listenForCalls() {
      db.ref("calls").on("child_added", (snapshot) => {
        const callId = snapshot.key;
        const callData = snapshot.val();
        
        debugLog('New call detected: ' + callId);
        
        // Check if this call is for current user and not initiated by them
        if (callData.receiverId === currentUserId && 
            callData.callerId !== currentUserId && 
            callData.status === "calling" &&
            !callInProgress) {
          debugLog('Incoming call for current user');
          handleIncomingCall(callId, callData);
        }
      });
    }

    // Auth state
    auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(console.error);

    auth.onAuthStateChanged((user) => {
      if (user) {
        currentUserId = user.uid;
        db.ref(`users/${currentUserId}`).update({ online: true });
        db.ref(`users/${currentUserId}`).onDisconnect().update({
          online: false,
          lastOnline: firebase.database.ServerValue.TIMESTAMP
        });
        loadUsers();
        listenForCalls();
        document.getElementById("loginDiv").style.display = "none";
        document.getElementById("chatDiv").style.display = "block";
        
        debugLog('User authenticated: ' + user.email);
      } else {
        document.getElementById("loginDiv").style.display = "block";
        document.getElementById("chatDiv").style.display = "none";
        debugLog('User logged out');
      }
    });

    // Mobile device detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    console.log("Mobile device detected:", isMobile);
    debugLog("Mobile device: " + isMobile);
  </script>
</body>
</html>
